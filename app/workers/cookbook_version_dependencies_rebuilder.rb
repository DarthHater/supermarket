class CookbookVersionDependenciesRebuilder
  include Sidekiq::Worker

  def initialize(options = {})
    @tarball = options[:tarball]
  end

  def perform(id)
    verified = VerifiedCookbookVersion.where(cookbook_version_id: id).first

    return if verified

    cookbook_version = CookbookVersion.find(id)

    metadata = CookbookUpload::Parameters.new(
      cookbook: '{}',
      tarball: fetch_tarball(cookbook_version)
    ).metadata

    # Not all metadata is well-formed. This is a map of known translations.
    known_constraint_replacements = {
      '>>' => '>',
      '<<' => '<'
    }

    metadata.dependencies.each do |name, constraint|
      constraints = Array(constraint).map do |original|
        known_constraint_replacements.reduce(original) do |updated, (old, new)|
          updated.gsub(old, new)
        end
      end

      existing_constraint = Chef::VersionConstraint.new(constraints).to_s

      # Some constraint values are +nil+, which likley means they were not
      # generated by knife. In this case, +constraints+ is +[]+, and so
      # +constraints.first+ is +nil+. Knife would specify this as '>= 0.0.0',
      # so that's what we do.
      valid_constraint = constraints.first || '>= 0.0.0'

      next if existing_constraint == valid_constraint

      dependency = cookbook_version.cookbook_dependencies.where(
        name: name,
        version_constraint: existing_constraint
      ).first

      if dependency
        dependency.version_constraint = valid_constraint
        dependency.save!
      else
        deps = cookbook_version.cookbook_dependencies.map do |d|
          "#{d.name} (#{d.version_constraint})"
        end

        Rails.logger.warn %(
          Expected #{cookbook_version.cookbook.name}
          (#{cookbook_version.version}) to depend on #{name}
          (#{existing_constraint}). Depends on #{deps.join(', ')}.
        ).squish
      end
    end

    VerifiedCookbookVersion.create!(cookbook_version_id: cookbook_version.id)
    Rails.cache.delete(Api::V1::UniverseController::CACHE_KEY)
  end

  private

  #
  # Only called once per +perfom+, but provides a seam for injecting tarballs
  # when testing
  #
  def fetch_tarball(cookbook_version)
    if @tarball
      @tarball
    else
      url = URI(cookbook_version.tarball.url)

      tarball = Tempfile.new(cookbook_version.id.to_s, 'tmp').tap do |tb|
        tb.set_encoding 'ASCII-8BIT'
      end

      Net::HTTP.start(url.host, 80) do |http|
        http.request(Net::HTTP::Get.new(url.path)) do |response|
          response.read_body do |chunk|
            tarball.write(chunk)
          end
        end
      end

      tarball.tap(&:rewind)
    end
  end
end
